\documentclass[a4paper,10pt]{report}
\usepackage[utf8x]{inputenc}

\usepackage[brazil]{babel}
\usepackage{graphicx, url}
\usepackage{listings} % para código fonte

\usepackage{amssymb,amsmath}

\usepackage{mathptmx}

\usepackage{float} % para controlar o floating de objetos.

% opções do pacote listings
\lstset{
	numbers=left,
	language=make,
	stepnumber=1,
	firstnumber=1,
	numberstyle=\tiny,
	extendedchars=true,
	breaklines=true,
	showtabs=false,
	tabsize=2,
	frame=tb,
	basicstyle=\footnotesize,
	stringstyle=\ttfamily,
	showstringspaces=false
	backgroundcolor=\color{gray}
	font=monospace
}

\renewcommand{\lstlistingname}{Código}

\include{header}

% Title Page
\title{Tutorial \\ Projeto: ULA de 1 bit}
\author{Prof. Rogério Aparecido Gonçalves \\ rogerioag@utfpr.edu.br}

\begin{document}
\maketitle
\pagestyle{plain} % No headers, just page numbers
\pagenumbering{alph} % Roman numerals
% \tableofcontents
\cleardoublepage

\pagenumbering{arabic}

\setcounter{chapter}{1}
\setcounter{section}{0}


\section{Introdução}

\section{Templates to GHDL (t2ghdl)}
O projeto t2ghdl tem como objetivo a criação de templates ou modelos para facilitar a criação, execução de projetos em VHDL na ferramenta GHDL.
O t2ghdl está disponível para download na página do Prof. Rogério (http://rag.pro.br).
Dentro do diretório do t2ghdl tem uma diretório de templates (entidade e testbench), um arquivo README.txt (como os comandos básicos), o Makefile (que faz todo o trabalho) e este tutorial.
Os comandos de utilização seguem a sintaxe:

\begin{table}[H]
\centering
\caption{Comandos} % igual ao ambiente figura
\begin{tabular}{ll} % com este comando dizemos quantas colunas terá nossa tabela e a posição do texto dentro de cada coluna. Aqui temos três colunas (pois são três "c" dentre {}) e o texto estará centralizado em todas elas (indicado pelo "c", se quisermos alinhados à esquerda "l" ou direita "r"
\hline % este comando coloca uma linha na tabela
Comando & Ação, Significado \\ % esta é a primeira linha de nossa tabela. O símbolo "&" separa as colunas e "\\" indica que aquela linha acabou.
\hline
\hline
000 & Op0 & Operação AND, realizada pela Unidade Lógica. \\

\hline
\end{tabular}
\label{tab:decod_operacoes}
\end{table}

% \begin{description}
% \item [Criar diretórios do projeto e arquivos iniciais:] \emph{``make new PROJECT=nomeDoProjeto ARCH=tipoArquitetura IN=porta1,porta2,portaN OUT=porta1,porta2,portaN''}. Onde PROJECT:
% \item [Compilar, executar e visualizar:] \emph{``make compile TESTBENCH=nomeDoProjeto_tb''}, \emph{``make run TESTBENCH=nomeDoProjeto_tb''}, \emph{``make view TESTBENCH=nomeDoProjeto_tb''}. Onde TESTBENCH.
% \item[Comando faz tudo: compila, executa e visualiza:] \emph{``make all TESTBENCH=nomeDoProjeto_tb''}.
% \item[Comando para apagar diretorio de simulacao:] \emph{``make clean''}
% \end{description}

Makefile do modelo de projeto foi alterado para permitir a criação dos componentes com o mesmo comando, no mesmo projeto. A próxima seção exemplifica essa ideia de termos componentes formados por subcomponentes, e a forma de criarmos do componente mais simples para o mais complexo.

\section{Projeto: ULA de 1 bit}

Tomemos então como exemplo o nosso projeto de uma ULA (Unidade Lógica e Aritmética) de 1 bit. A Figura~\ref{fig:ULA_000} apresenta a ULA em um nível 0, esta é a visão da entidade de teste, que chamamos de testbench, pois temos o componente ULA e as variáveis/sinais (T\_A, T\_B, T\_Cin, T\_F2, T\_F1, T\_F0, T\_S e T\_Cout) que pertencerão a essa entidade de teste.
Por meio dessas variáveis que os bits dos casos de teste irão ser injetados para que os resultados sejam gerados pela entidade ULA, possibilitando a comparação com o resultado esperado em cada caso de teste.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{figuras/ULA_000.png}
%\includegraphics[scale=0.3]{figuras/ULA_000.png}
\caption{Visão da ULA em um nível 0}
\label{fig:ULA_000}
\end{figure}

Em um nível 1, podemos visualizar o detalhamento da ULA, expondo seus componentes, conforme podemos visualizar na Figura~\ref{fig:ULA_001}.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{figuras/ULA_001.png}
\caption{Visão da ULA em um nível 1, exposição dos componentes principais.}
\label{fig:ULA_001}
\end{figure}


\subsection {Análise e Levantamento de componentes}
Analisando nossa entidade ULA, conforme Figura~\ref{fig:ULA_001}, podemos verificar que a ULA tem um Somador, um Decodificador, uma UnidadeLogica e uma xor2.
O circuito da entidade Somador é apresentado na Figura~\ref{fig:Somador}, podemos ver que realiza a soma das variáveis de entrada A, B e Cin, sendo que Cin é o \emph{Carry} de entrada, o "vai-um" de uma possível coluna anterior.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{figuras/somador.png}
\caption{Circuito Somador.}
\label{fig:Somador}
\end{figure}

O circuito Decodificador é uma circuito para decoficar a operação codificada pela escolha das entradas F\_2, F\_1 e F\_0. O detalhamento da entidade Decodificador é apresentado na Figura~\ref{fig:Decodificador}.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{figuras/decodificador.png}
\caption{Circuito Decodificador.}
\label{fig:Decodificador}
\end{figure}

As operações suportadas pelo decodificador, consequentemente que são realizadas pela ULA, estão listadas na Tabela~\ref{tab:decod_operacoes}.

\begin{table}[H]
\centering
\caption{Operações suportadas} % igual ao ambiente figura
\begin{tabular}{ccl} % com este comando dizemos quantas colunas terá nossa tabela e a posição do texto dentro de cada coluna. Aqui temos três colunas (pois são três "c" dentre {}) e o texto estará centralizado em todas elas (indicado pelo "c", se quisermos alinhados à esquerda "l" ou direita "r"
\hline % este comando coloca uma linha na tabela
[F\_2][F\_1][F\_0] & Operação & Descrição \\ % esta é a primeira linha de nossa tabela. O símbolo "&" separa as colunas e "\\" indica que aquela linha acabou.
\hline
\hline
000 & Op0 & Operação AND, realizada pela Unidade Lógica. \\
001 & Op1 & Operação OR, realizada pela Unidade Lógica.  \\
010 & Op2 & Operação NAND, realizada pela Unidade Lógica. \\
011 & Op3 & Operação NOR, realizada pela Unidade Lógica.  \\
100 & Op4 & Operação XOR, realizada pela Unidade Lógica.  \\
101 & Op5 & Operação XNOR, realizada pela Unidade Lógica. \\
110 & Op6 & Operação NOT, realizada pela Unidade Lógica.  \\
111 & Op7 & Operação SOMA, realizada pela Somador. \\
\hline
\end{tabular}
\label{tab:decod_operacoes}
\end{table}

As operações suportadas pelo Decodificador de Op0 a Op6 irão selecionar as operações que a Unidade Lógica realiza de OpAND a OpNOT, conforme pode ser visto na Figura~\ref{fig:UnidadeLogica}. O sinal Op7 será ligado ao Somador na entrada OpSomador, entrada que habilita a operação do Somador.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{figuras/unidadeLogica.png}
\caption{Circuito UnidadeLogica.}
\label{fig:UnidadeLogica}
\end{figure}

Feita essa análise e detalhamento de cada componente, verificamos os subcomponentes de cada componente principal da ULA. Assim, podemos resumir a lista de componentes e suas dependências conforme apresentado na Tabela~\ref{tab:dep_componentes}.

\begin{table}[H]
\centering
\caption{Componentes principais e suas dependências} % igual ao ambiente figura
\begin{tabular}{ll} % com este comando dizemos quantas colunas terá nossa tabela e a posição do texto dentro de cada coluna. Aqui temos três colunas (pois são três "c" dentre {}) e o texto estará centralizado em todas elas (indicado pelo "c", se quisermos alinhados à esquerda "l" ou direita "r"
\hline % este comando coloca uma linha na tabela
Componente & Dependências \\ % esta é a primeira linha de nossa tabela. O símbolo "&" separa as colunas e "\\" indica que aquela linha acabou.
\hline
\hline
ULA & Somador, Decodificador, UnidadeLogica e or2 \\
Somador & xor2, and2, and3 e or3 \\
Decodificador & and3 e inversor \\
UnidadeLogica & or3, and2, or2, nand2, nor2, xor2, xnor2 e inversor \\
\hline
\end{tabular}
\label{tab:dep_componentes}
\end{table} 

\section{Criação dos Componentes com o t2ghdl}

Para satisfazer as dependências da entidade Somador precisamos então criar os componentes básicos, and2, and3, or3 e xor2. O Código~\ref{cod:criar:ent_basicas} apresenta os comandos do Makefile para obter esse resultado. Note que a arquitetura para esses elementos básicos, neste caso portas lógicas, foi definida como lógica, por meio da variável ARCH.

\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=3pt}
\begin{lstlisting}[label=cod:criar:ent_basicas,caption=Comandos para a criação das entidades básicas]
  make new PROJECT=and2 ARCH=logica IN=a,b OUT=y
  make new PROJECT=and3 ARCH=logica IN=a,b,c OUT=y
  make new PROJECT=or3 ARCH=logica IN=a,b,c OUT=y
  make new PROJECT=xor2 ARCH=logica IN=a,b OUT=y
\end{lstlisting}

Se verificarmos na estrutura do projeto, foram criados os arquivos das entidades no diretório src e dos testes no diretório testbench. Esse componentes se quisermos fazer o testbench, tudo bem, mas por serem simples portas não precisaria, logo os arquivos dos testbenchs dessas unidades básicas poderiam ser descartados.
O Código~\ref{cod:and2} mostra como o código VHDL para a entidade and2 foi criado pelo make, sendo necessário somente colocarmos o tipo das variáveis e a expressão lógica (y <= a and b) que gera o resultado.

\lstset{language=VHDL}
\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=3pt}
\begin{lstlisting}[label=cod:and2,caption=Código VHDL da entidade and2]
-- Projeto gerado via script.
-- Data: Qua,20/07/2011-13:51:31
-- Autor: rogerio
-- Comentario: Descricao da Entidade: and2.
 
library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
 
entity and2 is
  port (a,b: in std_logic; y: out std_logic);
end and2;
 
architecture logica of and2 is
begin
  -- Comandos.
  y <= a and b;
end logica;
 
\end{lstlisting}

No diretorio testbench foi criado o arquivo and2\_tb.vhd que é o testbench para a entidade and2, conforme podemos ver no Código~\ref{cod:and2_tb}, novamente alteramos type para std\_logic e criamos os casos de teste.

\lstset{language=VHDL}
\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=3pt}
\begin{lstlisting}[label=cod:and2_tb,caption=Código VHDL do testebench para entidade and2]
-- Testebench gerado via script.
-- Data: Qua,20/07/2011-14:18:43
-- Autor: rogerio
-- Comentario: Teste da entidade and2.

library ieee;
use ieee.std_logic_1164.all;

entity and2_tb is
end and2_tb;

architecture logica of and2_tb is
  --  Declaracao do componente.
  component and2
    	port (a,b: in std_logic; y: out std_logic);
  end component;
  --  Especifica qual a entidade esta vinculada com o componente.
  for and2_0: and2 use entity work.and2;
      signal s_t_a, s_t_b, s_t_y: std_logic;
  begin
    --  Instanciacao do Componente.
    and2_0: and2 port map (a=>s_t_a,b=>s_t_b,y=>s_t_y);

    --  Processo que faz o trabalho.
    process
	-- Um registro e criado com as entradas e saidas da entidade.
	-- (<<entrada1>>, <<entradaN>>, <<saida1>>, <<saidaN>>)
	type pattern_type is record
	-- entradas.
		vi_a,vi_b: std_logic;
	-- saidas.
		vo_y: std_logic;
	end record;

	--  Os padroes de entrada sao aplicados (injetados) as entradas.
	type pattern_array is array (natural range <>) of pattern_type;
	constant patterns : pattern_array :=
	(
		('0', '0', '0'),
		('0', '1', '0'),
		('1', '0', '0'),
		('1', '1', '1')						
	);
	begin
	  --  Checagem de padroes.
	  for i in patterns'range loop
	    --  Injeta as entradas.
		s_t_a <= patterns(i).vi_a;
		s_t_b <= patterns(i).vi_b;
				
		--  Aguarda os resultados.
		wait for 1 ns;
		--  Checa o resultado com a saida esperada no padrao.
		assert s_t_y = patterns(i).vo_y	report "Valor de s_t_y nao confere com o resultado esperado." severity error;
						
	  end loop;
	  assert false report "Fim do teste." severity note;
	  --  Wait forever; Isto finaliza a simulacao.
	  wait;
	end process;
end logica;
\end{lstlisting}

Executando o comando make apresentado no Código~\ref{cod:testa:and2}, se tudo estiver correto, a entidade and2 será analisada e compilada e o teste será executado e no final será apresentado a tela do gtkwave com o diagrama de tempo (forma de onda).

\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=3pt}
\begin{lstlisting}[label=cod:testa:and2,caption=Comando para executar o testbench da entidade and2.]
  make all TESTBENCH=and2_tb
\end{lstlisting}

O digrama do resultado pode ser visualizado na Figura~\ref{fig:gtw:and2}.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{figuras/gtw_and2.png}
\caption{Diagrama de Tempo do teste da entidade and2.}
\label{fig:gtw:and2}
\end{figure}

Criadas as entidades básicas necessárias, então podemos criar a entidade principal Somador com o comando apresentado no Código~\ref{cod:criar:somador}. O Somador foi criado com a arquitetura estrutural com o valor da variável ARCH=estrutural.

\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=3pt}
\begin{lstlisting}[label=cod:criar:somador,caption=Comando para a criar a entidade Somador.]
  make new PROJECT=somador ARCH=estrutural IN=A,B,Cin,OpSomador OUT=S,Cout
\end{lstlisting}

Criada a entidade Somador apenas é necessário terminar a implementação do testbench para esta entidade, que neste caso consiste em criar os casos te teste.
Com o Somador funcionando, podemos ir para a próxima entidade, o Decodificador.
O Decodificador depende de algumas entidades básicas, a maioria já foi criada para satisfazer as dependências da entidade Somador, restando apenas a criação de um inversor, conforme o Código~\ref{cod:criar:inversor}.

\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=3pt}
\begin{lstlisting}[label=cod:criar:inversor,caption=Comando para a criar a entidade Inversor.]
  make new PROJECT=inversor ARCH=logica
\end{lstlisting}

Com todas as dependências do Decodificador satisfeitas, podemos então criá-lo, com o comando apresenta no Código~\ref{cod:criar:decodificador}.

\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=3pt}
\begin{lstlisting}[label=cod:criar:decodificador,caption=Comando para a criar a entidade Decodificador.]
  make new PROJECT=decodificador ARCH=estrutural
\end{lstlisting}

Implementa-se a entidade e testbench do decodificador, deixando-o funcionando.

A próxima entidade a ser criada então é a Unidade Lógica. Para esta entidade precisamos criar os componentes básicos que ainda não temos no projeto e que precisaremos para satisfazer a entidade unidadeLogica, sendo eles or2, nand2, nor2, xnor2. O comando para criá-los é apresentado no Código~\ref{cod:criar:outrasentbasicas}.

\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=3pt}
\begin{lstlisting}[label=cod:criar:outrasentbasicas,caption=Comando para a criar entidades básicas para a Unidade Lógica.]
  make new PROJECT=or2 ARCH=logica
  make new PROJECT=nand2 ARCH=logica
  make new PROJECT=nor2 ARCH=logica
  make new PROJECT=xnor2 ARCH=logica
\end{lstlisting}

Tendo todas as dependências satisfeitas, podemos então criar a entidade unidadeLogica, conforme o Código~\ref{cod:criar:unidadeLogica}.

\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=3pt}
\begin{lstlisting}[label=cod:criar:unidadeLogica,caption=Comando para a criar a entidade unidadeLogica.]
  make new PROJECT=unidadeLogica ARCH=estrutural
\end{lstlisting}

Implementa-se a entidade e testbench da unidadeLogica, deixando-a funcionando.

Até aqui, implementamos todos os componentes principais necessários para a implementação da ULA. Então podemos criar a entidade ULA, com o comando apresentado no Código~\ref{cod:criar:ULA}.

\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=3pt}
\begin{lstlisting}[label=cod:criar:ULA,caption=Comando para a criar a entidade ULA.]
  make new PROJECT=ula ARCH=estrutural
\end{lstlisting}

Verifica-se a implementação da entidade ULA e em seu testbench é necessário apenas a criação dos casos de teste. Testamos e a deixamos funcionando.
A técnica do menor para o maior, por composição permite ir testando e vendo os resultados dos componentes até atingir o resultado maior que é o projeto como um todo.

Se iniciássemos pela entidade ULA (do maior para o menor) iríamos poder testá-la somente no final, quando todos os componentes estivessem terminados, até lá, muitos erros iriam acontecer.

\end{document}          
